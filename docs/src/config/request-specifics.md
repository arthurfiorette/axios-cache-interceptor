# Request specifics

Each request can have its own cache customization, by using the `cache` property. This
way, you can have requests behaving differently from each other without much effort.

The inline documentation is self explanatory, but here is a brief overview of what each
property does:

::: tip

You can override every request specific property when creating the cached axios client,
the same way you do with the [global options](../config.md).

:::

## id

<Badge text="optional" type="warning"/>

- Type: `string`
- default: _(auto generated by the current
  [key generator](../guide/request-id.md#custom-generator))_

The [Request ID](../guide/request-id.md) used in this request.

It may have been generated by the [Key Generator](../guide/request-id.md#custom-generator)
or a custom one provided by [`config.id`](./request-specifics.md#id)

## cache

<Badge text="optional" type="warning"/>

- Type: `Partial<CacheProperties<R, D>>`.
- Default: `{}` _(Inherits from global configuration)_

::: tip

As this property is optional, when not provided, all properties will inherit from global
configuration

:::

The cache option available through the request config is where all the cache customization
happens.

You can pass an object with cache properties to customize cache behavior.

To disable caching for a specific request, use `cache: { enabled: false }`:

```ts
// Make a request with cache disabled
const { id: requestId } = await axios.get('url', {
  cache: { enabled: false }
});

// Delete the cache entry for this request if needed
await axios.storage.remove(requestId);
```

## cache.enabled

<Badge text="optional" type="warning"/>

- Type: `boolean`
- Default: `true`

Whether the cache is enabled for this request.

When set to `false`, the cache will be completely disabled for this request.

This is useful for **opt-in cache** scenarios where you want to disable cache globally
but enable it for specific requests.

### Example: Opt-in Cache Pattern

You can disable cache by default and enable it only for specific endpoints:

```ts
import { setupCache } from 'axios-cache-interceptor';

// Setup axios with cache disabled by default
const axios = setupCache(axiosInstance, {
  enabled: false // Disable cache globally
});

// Most requests won't use cache
await axios.get('/api/realtime-data'); // Not cached

// Enable cache for specific heavy/expensive requests
await axios.get('/api/heavy-computation', {
  cache: {
    enabled: true,
    ttl: 1000 * 60 * 10 // Cache for 10 minutes
  }
}); // Cached
```

### Example: Traditional Pattern (Opt-out)

The traditional pattern where cache is enabled by default:

```ts
import { setupCache } from 'axios-cache-interceptor';

// Setup axios with cache enabled by default (this is the default behavior)
const axios = setupCache(axiosInstance, {
  enabled: true // or omit this as true is the default
});

// Most requests will use cache
await axios.get('/api/user-profile'); // Cached

// Disable cache for specific real-time endpoints
await axios.get('/api/live-stock-prices', {
  cache: { enabled: false }
}); // Not cached
```

## cache.ttl

<Badge text="optional" type="warning"/>

- Type: `number | ((response: CacheAxiosResponse) => number | Promise<number>)`
- Default: `1000 * 60 * 5` _(5 Minutes)_

::: warning

When using [**interpretHeader**](#cache-interpretheader), this value will only be used if
the interpreter can't determine their TTL value to override this one.

:::

The time until the cached value is expired in milliseconds.

### Type Definition

This option accepts two value types:

| Type       | Description                   | When to Use                                                      |
| ---------- | ----------------------------- | ---------------------------------------------------------------- |
| `number`   | Static TTL in milliseconds    | When all responses should have the same cache duration           |
| `function` | Dynamic TTL based on response | When cache duration depends on response data, headers, or status |

**Function Signature:**

```ts
type TTLFunction = (
  response: CacheAxiosResponse
) => number | Promise<number>;
```

**Parameters:**

| Parameter  | Type                 | Description                                            |
| ---------- | -------------------- | ------------------------------------------------------ |
| `response` | `CacheAxiosResponse` | The complete Axios response object with cache metadata |

**Return Value:**

| Type              | Description                                 |
| ----------------- | ------------------------------------------- |
| `number`          | TTL in milliseconds                         |
| `Promise<number>` | Asynchronously computed TTL in milliseconds |

### Examples

**Static TTL (Basic):**

```ts
axios.get('/api/users', {
  cache: {
    ttl: 1000 * 60 * 10 // 10 minutes
  }
});
```

**Dynamic TTL Based on Response Status:**

```ts
axios.get('/api/data', {
  cache: {
    ttl: (response) => {
      // Cache successful responses longer
      if (response.status === 200) {
        return 1000 * 60 * 30; // 30 minutes
      }
      // Cache errors for shorter time
      return 1000 * 60 * 5; // 5 minutes
    }
  }
});
```

**TTL Based on Response Data:**

```ts
interface ApiResponse {
  priority: 'high' | 'low';
  data: unknown;
}

axios.get<ApiResponse>('/api/resource', {
  cache: {
    ttl: (response) => {
      // Use different TTL based on response data
      return response.data.priority === 'high'
        ? 1000 * 60 * 60 // 1 hour for high priority
        : 1000 * 60 * 10; // 10 minutes for low priority
    }
  }
});
```

**Async TTL Calculation:**

```ts
axios.get('/api/dynamic', {
  cache: {
    ttl: async (response) => {
      // Calculate based on external config or response headers
      const config = await fetchCacheConfig();
      return response.data.priority === 'high'
        ? config.highPriorityTTL
        : config.defaultTTL;
    }
  }
});
```

**Server-Provided Expiration:**

```ts
interface ResourceResponse {
  expiresIn: number; // seconds until expiration
  data: unknown;
}

axios.get<ResourceResponse>('/api/resource', {
  cache: {
    ttl: (response) => {
      // Use server-provided expiration time
      return response.data.expiresIn * 1000; // Convert seconds to milliseconds
    }
  }
});
```

## cache.interpretHeader

<Badge text="optional" type="warning"/>

- Type: `boolean`
- Default: `true`

If activated, when the response is received, the `ttl` property will be inferred from the
requests headers. As described in the MDN docs and HTML specification.

See the actual implementation of the
[`interpretHeader`](https://github.com/arthurfiorette/axios-cache-interceptor/blob/main/src/header/interpreter.ts)
method for more information.

## cache.cacheTakeover

<Badge text="optional" type="warning"/>

- Type: `boolean`
- Default: `true`

As most of our cache strategies depend on well-known HTTP headers, most browsers also use those headers to define their own cache strategies and storages.

::: details This can be seen when opening network tab in your browser's dev tools.

![Network tab in Chrome Dev Tools](../assets/disk-cache-screenshot.png 'A network disk-cache example')

:::

When your requested routes include `Cache-Control` in their responses, you may end up with both the library and your browser caching the response, resulting in a **double layer of cache**.

This option solves this by including predefined headers in the request that instruct any client/adapter to not cache the response, thus ensuring only the library caches it.

**These headers are added to your specific request and won't affect any other request or response that the server may handle.**

Headers included:

- `Cache-Control: no-cache, no-store, must-revalidate, max-age=0`
- `Pragma: no-cache`
- `Expires: 0`

::: info Safari Compatibility

The `max-age=0` directive was added to ensure compatibility with Safari (including iOS Safari), which has historically been more aggressive with caching and may not fully respect the `no-cache` directive alone. This combination of headers ensures reliable cache prevention across all major browsers.

:::

::: tip Alternative

While `cacheTakeover` works for most browsers according to [this StackOverflow answer](https://stackoverflow.com/a/2068407), in some rare edge cases it may be unreliable due to browser-specific cache behaviors or network intermediaries.

For maximum reliability, add a unique random query parameter instead:

```ts
axios.get(
  `/api/data?cachebuster=${Math.random().toString(36).slice(2)}`,
  {
    id: 'api-data-endpoint' // Keep same cache key despite different URLs
  }
);
```

Your backend can ignore the `cachebuster` value. This **guarantees** no browser caching while preserving axios-cache-interceptor functionality.

:::

::: warning CORS Considerations

This option will not work on **CORS** requests with restricted headers, as the browser will throw:
`Request header field Pragma is not allowed by Access-Control-Allow-Headers in preflight response.`

When you encounter CORS errors, you need to ensure `Cache-Control`, `Pragma`, and `Expires` headers are included in your server's `Access-Control-Allow-Headers` CORS configuration.

If you cannot modify the CORS configuration, you can:

1. Disable this option (`cacheTakeover: false`)
2. Use the query parameter approach mentioned above

Learn more about why this should be enabled at [#437](https://github.com/arthurfiorette/axios-cache-interceptor/issues/437#issuecomment-1361262194) and in this [StackOverflow answer](https://stackoverflow.com/a/2068407).

:::

## cache.methods

<Badge text="optional" type="warning"/>

- Type: `Method[]`
- Default: `["get", "head"]`

Specifies which methods we should handle and cache. This is where you can enable caching
to `POST`, `PUT`, `DELETE` and other methods, as the default is only `GET`.

If you want to enable cache for `POST` requests, you can do:

```ts
// Globally enables caching for POST requests
const axios = setupCache(instance, {
  methods: ['get', 'post']
});

// Just for this request
axios.post('url', data, {
  cache: {
    methods: ['post']
  }
});
```

We use `methods` in a per-request configuration setup because sometimes you have
exceptions to the method rule.

## cache.cachePredicate

<Badge text="optional" type="warning"/>

- Type: `CachePredicate<R, D>`
- Default:
  `{ statusCheck: (status) => [200, 203, 300, 301, 302, 404, 405, 410, 414, 501].includes(status) }`
  _(These default status codes follows RFC 7231)_

An object or function that will be tested against the response to indicate if it can be
cached. You can use `statusCheck`, `containsHeader`, `ignoreUrls`, `allowUrls` and
`responseMatch` to test against the response.

If both `ignoreUrls` & `allowUrls` are matched, `ignoreUrls` take precedence.

```ts{5,8,13}
axios.get<{ auth: { status: string } }>('url', {
  cache: {
    cachePredicate: {
      // Only cache if the response comes with a "good" status code
      statusCheck: (status) =>  true, // some calculation

      // Tests against any header present in the response.
      containsHeaders: {
        'x-custom-header-3': (value) => true // some calculation
      },

      // Check custom response body
      responseMatch: ({ data }) => {
        // Sample that only caches if the response is authenticated
        return data.auth.status === 'authenticated';
      },

      // Ensures no request is cached if its url starts with "/api"
      ignoreUrls: [/^\/api/]

      // only cache request urls that includes "weekly"
      allowUrls: ['weekly']
    }
  }
});
```

## cache.update

<Badge text="optional" type="warning"/>

- Type: `CacheUpdater<R, D>`
- Default: `{}`

Once the request is resolved, this specifies what other responses should change their
cache. Can be used to update the request or delete other caches. It is a simple `Record`
with the request id.

Here's an example with some basic logic:

Using a function instead of an object is supported but not recommended, as it's better to
just consume the response normally and write your own code after it. But it`s here in case
you need it.

```ts
// Some requests id's
let profileInfoId;
let userInfoId;

axios.post<{ auth: { user: User } }>(
  'login',
  { username, password },
  {
    cache: {
      update: {
        // Evicts the profile info cache, because now he is authenticated and the response needs to be re-fetched
        [profileInfoId]: 'delete',

        // An example that update the "user info response cache" when doing a login.
        // Imagine this request is a login one.
        [userInfoResponseId]: (cachedValue, response) => {
          if (cachedValue.state !== 'cached') {
            // Only needs to update if the response is cached
            return 'ignore';
          }

          cachedValue.data = data;

          // This returned value will be returned in next calls to the cache.
          return cachedValue;
        }
      }
    }
  }
);
```

## cache.etag

<Badge text="optional" type="warning"/>

- Type: `string | boolean`
- Default: `true`

Configures [`ETag`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/ETag) and [`If-None-Match`](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/If-None-Match) header handling for cache revalidation.

### Type Definition

| Value Type | Behavior                                       | When to Use                                                                  |
| ---------- | ---------------------------------------------- | ---------------------------------------------------------------------------- |
| `true`     | Automatically uses ETag from previous response | Standard ETag-based revalidation (recommended)                               |
| `false`    | Disables ETag handling                         | When server doesn't support ETags or you want to use `modifiedSince` instead |
| `string`   | Forces a custom static ETag value              | Testing or special server requirements                                       |

To use `true` (automatic ETag handling), `interpretHeader` option must be set to `true`.

### Examples

**Automatic ETag (Default):**

```ts
// First request
const res1 = await axios.get('/api/users', {
  cache: { etag: true }
});
// Server responds with: ETag: "abc123"

// Second request after cache expires
// Automatically sends: If-None-Match: "abc123"
// Server responds with 304 Not Modified or new data with new ETag
const res2 = await axios.get('/api/users');
```

**Force Custom Static ETag:**

```ts
axios.get('/api/resource', {
  cache: {
    etag: '"my-custom-etag-value"'
  }
});
// Always sends: If-None-Match: "my-custom-etag-value"
```

**Disable ETag:**

```ts
axios.get('/api/realtime', {
  cache: {
    etag: false,
    modifiedSince: false // Usually also disabled for realtime data
  }
});
```

## cache.modifiedSince

<Badge text="optional" type="warning"/>

- Type: `Date | boolean`
- Default: `false` (automatically set to `true` if `etag` is `false`)

Configures [`If-Modified-Since`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since) header handling for cache revalidation.

### Type Definition

| Value Type | Behavior                                                          | When to Use                                          |
| ---------- | ----------------------------------------------------------------- | ---------------------------------------------------- |
| `true`     | Automatically uses Last-Modified from response or cache timestamp | When server supports Last-Modified but not ETag      |
| `false`    | Disables If-Modified-Since header                                 | Default when ETag is enabled (ETag takes precedence) |
| `Date`     | Forces a custom static date value                                 | Testing or special server requirements               |

If never cached before, the header is not set.

If `interpretHeader` is set and a [`Last-Modified`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified) header is sent to us, then the value from that header is used. Otherwise, the cache creation timestamp will be sent in [`If-Modified-Since`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since).

### Examples

**Automatic If-Modified-Since (When ETag is disabled):**

```ts
// First request
const res1 = await axios.get('/api/document', {
  cache: {
    etag: false,
    modifiedSince: true
  }
});
// Server responds with: Last-Modified: Mon, 10 Feb 2025 10:00:00 GMT

// Second request after cache expires
// Automatically sends: If-Modified-Since: Mon, 10 Feb 2025 10:00:00 GMT
const res2 = await axios.get('/api/document');
```

**Force Custom Date:**

```ts
axios.get('/api/data', {
  cache: {
    modifiedSince: new Date('2025-01-01T00:00:00Z')
  }
});
// Always sends: If-Modified-Since: Wed, 01 Jan 2025 00:00:00 GMT
```

**Typical Configuration:**

```ts
// ETag preferred (default)
axios.get('/api/modern', {
  cache: {
    etag: true,
    modifiedSince: false // Default when etag is true
  }
});

// If-Modified-Since for legacy servers
axios.get('/api/legacy', {
  cache: {
    etag: false,
    modifiedSince: true // Automatically set to true when etag is false
  }
});
```

## cache.staleIfError

- Type: `number | boolean | StaleIfErrorPredicate<R, D>`
- Default: `true`

Enables cache to be returned if the response comes with an error, either by invalid status code, network errors, etc. You can filter the type of error that should be stale by using a predicate function.

### Type Definition

This option accepts three value types:

| Type       | Behavior                                                    | When to Use                                   |
| ---------- | ----------------------------------------------------------- | --------------------------------------------- |
| `true`     | Return stale cache for any error with infinite grace period | Default behavior, maximizes availability      |
| `false`    | Never return stale cache on errors                          | When you want errors to propagate immediately |
| `number`   | Max time in seconds that stale cache can be used            | Time-limited grace period for errors          |
| `function` | Custom logic to determine if/when to use stale cache        | Complex error handling scenarios              |

**Predicate Function Signature:**

```ts
type StaleIfErrorPredicate = (
  networkResponse: CacheAxiosResponse | undefined,
  cache: LoadingStorageValue & { previous: 'stale' },
  error: Record<string, unknown>
) => number | boolean | Promise<number | boolean>;
```

**Parameters:**

| Parameter         | Type                                          | Description                                                                 |
| ----------------- | --------------------------------------------- | --------------------------------------------------------------------------- |
| `networkResponse` | `CacheAxiosResponse \| undefined`             | The failed network response if available, or `undefined` for network errors |
| `cache`           | `LoadingStorageValue & { previous: 'stale' }` | The stale cache entry being considered for return                           |
| `error`           | `Record<string, unknown>`                     | The error object from the failed request                                    |

**Return Value:**

| Type     | Meaning                                                              |
| -------- | -------------------------------------------------------------------- |
| `false`  | Do not return stale cache, propagate error                           |
| `true`   | Return stale cache with infinite grace period                        |
| `number` | Return stale cache only if it has been stale for less than N seconds |

::: warning

If the response is treated as error because of invalid status code _(like when using [statusCheck](#cache-cachepredicate))_, and this ends up `true`, the cache will be preserved over the "invalid" request.

:::

### Examples

**Enable Stale-If-Error (Default):**

```ts
// Automatically returns stale cache on any error
axios.get('/api/critical-data', {
  cache: {
    staleIfError: true
  }
});
```

**Time-Limited Stale Grace Period:**

```ts
// Return stale cache only if error occurs within 60 seconds of staleness
axios.get('/api/data', {
  cache: {
    staleIfError: 60 // seconds
  }
});
```

**Conditional Stale Return (Predicate):**

```ts
axios.get('/api/users', {
  cache: {
    staleIfError: (response, cache, error) => {
      // Only return stale cache for network errors, not bad status codes
      if (response) {
        return false; // Has response, don't use stale
      }

      // Network error - check cache age
      const cacheAge = Date.now() - cache.createdAt;
      const maxStaleAge = 1000 * 60 * 5; // 5 minutes

      return cacheAge < maxStaleAge;
    }
  }
});
```

**Different Behavior by Error Type:**

```ts
axios.get('/api/resource', {
  cache: {
    staleIfError: (response, cache, error) => {
      // Network timeout: use stale cache
      if (error.code === 'ECONNABORTED') {
        return true;
      }

      // 5xx server errors: use stale cache for up to 30 seconds
      if (response && response.status >= 500) {
        return 30;
      }

      // 4xx client errors: don't use stale cache
      return false;
    }
  }
});
```

**Preserve Stale Only on Network Errors:**

```ts
const customPredicate = (response, cache, error) => {
  // Blocks staleIfError if has a response
  return !response;

  // Note that this still respects axios default implementation
  // and throws an error (but it keeps the response)
};

axios.get('/api/data', {
  cache: {
    staleIfError: customPredicate
  }
});
```

## cache.override

<Badge text="optional" type="warning"/>

- Type: `boolean`
- Default: `false`

This option bypasses the current cache and always make a new http request. This will not
delete the current cache, it will just replace the cache when the response arrives.

Unlike as `cache: false`, this will not disable the cache, it will just ignore the
pre-request cache checks before making the request. This way, all post-request options are
still available and will work as expected.

## cache.vary

<Badge text="optional" type="warning"/>

- Type: `string[] | boolean`
- Default: `true`

Configure HTTP Vary header handling.

- `true`: Automatic vary handling (default, recommended)
- `false`: Disable vary checking (**WARNING: can cause cache poisoning**)
- `string[]`: Overrides server sent Vary and use specific request headers in cache key

When the server responds with a `Vary` header, the cache key is adjusted to include the specified request headers:

```ts
// Request with Authorization header
await axios.get('/api/users', {
  headers: { authorization: 'Bearer token-A' }
});
// Server responds: Vary: Authorization
// Cached with ID based on: url + method + params + {authorization: 'Bearer token-A'}

// Different authorization = different cache
await axios.get('/api/users', {
  headers: { authorization: 'Bearer token-B' }
});
// Gets its own cache (different ID due to different authorization)
```

## cache.hydrate

<Badge text="optional" type="warning"/>

- Type: `undefined | ((cache: StorageValue) => void | Promise<void>)`
- Default: `undefined`

Asynchronously called when a network request is needed to resolve the data, but an older one **and probably expired** cache exists. Calls it with the current data **BEFORE** the network request starts, so you can use it to temporarily update your UI with expired data before the network returns.

Hydrating your components with old data before the network resolves with the newer one is
better than _flickering_ your entire UI. This is even better when dealing with slower
networks and persisted cache, like for mobile apps.

::: warning

If the axios call will return cached data, meaning no network will be involved, the
hydrate **IS NOT CALLED**, as the axios promise will be resolved instantly.

:::

```ts {7,13}
// Example of function that receives data and renders into a screen
function render() {}

const response = await axios.get(/* [!code focus:10] */ 'url', {
  // This is called instantly if axios needs to make a network request
  cache: {
    hydrate: (cache) => render(cache.data)
  }
});

// After the network lookup ends, we have fresh data and can
// re-render the UI with confidence
render(response.data);
```
